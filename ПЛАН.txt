1) Создать проект PyCharm
2) Прописать класс создания графа с изменяемым количеством:
   а) вершин (N ~ 3 - 100)
   б) связей между вершинами (регулируется с помощью интервала 0,1-0,8 - как пример с ползунком!!!)
3) создать класс поиска клик по графу, регулируется с помощью свойства (алгоритм поиска), существующие алгоритмы поиска клик:

   ПРИ ЭТОМ СЛЕДУЕТ ПОМНИТЬ О ТОМ, КЛИКИ С КАКИМ КОЛИЧЕСТВОМ ВЕРШИН ( МАКСИМАЛЬНЫМ?) ТРЕБУЕТСЯ ИСКАТЬ!?
   В ДАННЫЙ МОМЕНТ НАИБОЛЕЕ ОПТИМАЛЬНЫМ ВЫГЛЯДИТ ПОИСК КЛИК С КОЛИЧЕСТВОМ ВЕРШИН = 5 (Т = 5)

   ПРОДУМАТЬ, СТОИТ ЛИ ПРОВОДИТЬ ПОИСК ТОЛЬКО КЛИК С МАКСИМАЛЬНЫМ КОЛИЧЕСТВОМ ВЕРШИН
   ИЛИ ИСКАТЬ ВСЕ КЛИКИ И ЗАТЕМ ГРУППИРОВАТЬ ИХ НА ВЫХОДЕ В ЗАВИСИМОСТИ ОТ КОЛИЧЕСТВА ВЕРШИН??? 

   а) Брона-Кербоша, URL:
   https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%80%D0%BE%D0%BD%D0%B0_%E2%80%94_%D0%9A%D0%B5%D1%80%D0%B1%D0%BE%D1%88%D0%B0
   
	Алгоритм использует тот факт, что всякая клика в графе является его максимальным по включению полным подграфом.
	Начиная с одиночной вершины (образующей полный подграф), алгоритм на каждом шаге пытается увеличить уже построенный полный подграф,
	добавляя в него вершины из множества кандидатов. Высокая скорость обеспечивается отсечением при переборе вариантов,
	которые заведомо не приведут к построению клики, для чего используется дополнительное множество, в которое помещаются вершины,
	которые уже были использованы для увеличения полного подграфа.

	Алгоритм оперирует тремя множествами вершин графа:

	Множество compsub — множество, содержащее на каждом шаге рекурсии полный подграф для данного шага. Строится рекурсивно.
	Множество candidates — множество вершин, которые могут увеличить compsub
	Множество not — множество вершин, которые уже использовались для расширения compsub на предыдущих шагах алгоритма.
	Алгоритм является рекурсивной процедурой, применяемой к этим трем множествам.

	ПРОЦЕДУРА extend (candidates, not):
  	ПОКА candidates НЕ пусто И not НЕ содержит вершины, СОЕДИНЕННОЙ СО ВСЕМИ вершинами из candidates, 
  	ВЫПОЛНЯТЬ:
  	1 Выбираем вершину v из candidates и добавляем её в compsub
  	2 Формируем new_candidates и new_not, удаляя из candidates и not вершины, не СОЕДИНЕННЫЕ с v
  	3 ЕСЛИ new_candidates и new_not пусты
  	4 ТО compsub – клика
  	5 ИНАЧЕ рекурсивно вызываем extend (new_candidates, new_not)
  	6 Удаляем v из compsub и candidates, и помещаем в not

   б) AllIS
   https://elibrary.ru/download/elibrary_18894702_73378426.pdf

	НАХОЖДЕНИЕ ВСЕХ МАКСИМАЛЬНЫХ НЕЗАВИСИМЫХ МНОЖЕСТВ НЕОРИЕНТИРОВАННОГО ГРАФА
	ФИРЮЛИНА ОКСАНА СЕРГЕЕВНА

	Аннотация
	В статье представлен алгоритм поиска всех максимальных независимых множеств в неориентированном графе.
	Эта задача принадлежит к числу так называемых NP-полных задач, что означает отсутствие в настоящее время алгоритмов,
	решающих ее за полиномиальноевремя. Несмотря на то, что предлагаемый алгоритм также не является полиномиальным,
	в худших случаях он находит решение быстрее, чем тривиальный алгоритм полного перебора.
	Каждая ветвь дерева поиска, построенного по алгоритму AllIS, соответствует уникальному максимальному независимому множеству.
	Приведены результаты сравнения работы рассматриваемого алгоритма и известного алгоритма Брона–Кербоша для нахождения всех
	максимальных независимых множеств на некотором наборе произвольных графов с различными значениями плотности.
	Особое внимание уделяется сравнению работы алгоритмов на разреженных графах.